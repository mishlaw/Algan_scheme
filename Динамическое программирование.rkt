#lang racket
;Плитка
(define (fib n)
(define (iter k a b)
(if (= k n) b

(iter (+ k 1) b (+ a b))))

(iter 1 1 1))

;Мячик на лесенке
(define (ball n)
(define (iter k a b c)

(if (= k n) b

(iter (+ k 1) b c (+ a b c))))

(cond

((= n 1) 1)
((= n 2) 2)
(else (iter 3 1 2 4))))

;Черепашка (наименьшая стоимость пути)
; В процессе реализации вычислений нам удобно создать
; функцию построения матрицы стоимостей таким образом, как
; будто мы идем в обратную сторону.
;Вводить матрицу нужно развернутой (последняя строчка в начале, первая - в конце. И сами строчки развернуть (т.е справа налево)
(define (lst-sum lst) ;Находит нижнюю строчку матрицы сумм
(reverse (foldl (lambda (x rez) (cons (+ x (car rez)) rez)) (list (car lst)) (cdr lst))))

(define (matr-sum A)
(reverse (foldl (lambda (lst rez)
                  (cons (reverse (foldl (lambda (x y str) (if (< y (car str))
                                                              (cons (+ x y) str)
                                                              (cons (+ x (car str)) str)))
                                        (list (+ (car lst) (caar rez))) (cdr lst) (cdar rez)))  rez))
                (list (lst-sum (car A))) (cdr A))))

; В результате работы этой функции получим матрицу сумм.
; Последний элемент этой матрицы является ответом на вопрос о
; стоимости оптимального пути. Для получения самого маршрута
; достаточно, пользуясь этой матрицей сумм, перемещаться в
; 
; обратном направлении, т.е. влево и вверх, переходя на каждом
; шаге к той из двух соседних клеток, где сумма меньше.